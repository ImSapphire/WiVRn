From 038b4f316cbb432e00ccded3e493af82f28cec45 Mon Sep 17 00:00:00 2001
From: rcelyte <rcelyte@battletrains.org>
Date: Mon, 15 Sep 2025 22:46:15 +0000
Subject: [PATCH 6/8] d/solarxr: Feed device poses to server

---
 src/xrt/drivers/CMakeLists.txt              |   2 +
 src/xrt/drivers/solarxr/feeder.c            | 328 ++++++++++++++++++++
 src/xrt/drivers/solarxr/feeder.h            |  62 ++++
 src/xrt/drivers/solarxr/protocol.h          |  30 +-
 src/xrt/drivers/solarxr/solarxr_device.c    | 157 ++++++----
 src/xrt/drivers/solarxr/solarxr_interface.h |   3 +
 6 files changed, 518 insertions(+), 64 deletions(-)
 create mode 100644 src/xrt/drivers/solarxr/feeder.c
 create mode 100644 src/xrt/drivers/solarxr/feeder.h

diff --git a/src/xrt/drivers/CMakeLists.txt b/src/xrt/drivers/CMakeLists.txt
index bd31b3374..f8406e0f3 100644
--- a/src/xrt/drivers/CMakeLists.txt
+++ b/src/xrt/drivers/CMakeLists.txt
@@ -529,6 +529,8 @@ endif()
 if(XRT_BUILD_DRIVER_SOLARXR)
 	add_library(
 		drv_solarxr STATIC
+		solarxr/feeder.c
+		solarxr/feeder.h
 		solarxr/protocol.c
 		solarxr/protocol.h
 		solarxr/solarxr_device.c
diff --git a/src/xrt/drivers/solarxr/feeder.c b/src/xrt/drivers/solarxr/feeder.c
new file mode 100644
index 000000000..3e9a8de73
--- /dev/null
+++ b/src/xrt/drivers/solarxr/feeder.c
@@ -0,0 +1,328 @@
+// Copyright 2025, rcelyte
+// SPDX-License-Identifier: BSL-1.0
+/*!
+ * @file
+ * @brief  SolarXR pose feeder
+ * @ingroup drv_solarxr
+ */
+
+#include "feeder.h"
+#include "solarxr_ipc_message.h"
+
+#include "xrt/xrt_device.h"
+
+#include <math.h>
+
+#define PROTOBUF_FLOAT(v_) ((uint8_t *)&(v_))[0], ((uint8_t *)&(v_))[1], ((uint8_t *)&(v_))[2], ((uint8_t *)&(v_))[3]
+#define PROTOBUF_INT32(v_)                                                                                             \
+	(uint8_t)(0x80 | (uint32_t)(v_)), (uint8_t)(0x80 | (uint32_t)(v_) >> 7),                                       \
+	    (uint8_t)(0x80 | (uint32_t)(v_) >> 14), (uint8_t)(0x80 | (uint32_t)(v_) >> 21), (uint32_t)(v_) >> 28
+
+struct feeder_device
+{
+	struct xrt_listener base;
+	struct xrt_device *xdev; // weak reference
+	struct feeder *feeder;
+	enum xrt_input_name input_name;
+	uint32_t id;
+	uint8_t last_status;
+	bool battery_charging;
+	float battery_charge;
+};
+
+static void
+feeder_device_detach(struct xrt_listener *const listener, void *const data)
+{
+	(void)data;
+	struct feeder_device *const device = (struct feeder_device *)listener;
+	struct feeder *const feeder = device->feeder;
+	os_mutex_lock(&feeder->mutex);
+	assert(device->xdev != NULL);
+	U_LOG_IFL_D(feeder->socket.log_level, "device \"%.*s\" was destroyed", (unsigned)ARRAY_SIZE(device->xdev->str),
+	            device->xdev->str);
+	device->xdev = NULL;
+	xrt_list_remove(&listener->link);
+	os_mutex_unlock(&feeder->mutex);
+}
+
+void
+feeder_send_feedback(struct feeder *const feeder)
+{
+	if (!solarxr_ipc_socket_is_connected(&feeder->socket)) {
+		return;
+	}
+
+	// check for errors on the socket
+	if (!solarxr_ipc_socket_wait_timeout(&feeder->socket, 0)) {
+		U_LOG_IFL_E(feeder->socket.log_level, "connection lost");
+		solarxr_ipc_socket_destroy(&feeder->socket);
+		return;
+	}
+
+	os_mutex_lock(&feeder->mutex);
+
+	const timepoint_ns time = os_monotonic_get_ns();
+	uint8_t packet[0x10000], *packet_end = packet;
+	for (uint32_t i = 0, devices_len = feeder->devices_len; i < devices_len; ++i) {
+		struct feeder_device *const device = &feeder->devices[i];
+		uint8_t status = 0; // Status::DISCONNECTED
+
+		if (device->xdev != NULL) {
+			// report meaningful changes in battery level
+			bool present = false, charging = false;
+			float charge = 0;
+			if (device->xdev->supported.battery_status &&
+			    xrt_device_get_battery_status(device->xdev, &present, &charging, &charge) == XRT_SUCCESS &&
+			    (charging != device->battery_charging || fabsf(charge - device->battery_charge) >= 1e-05)) {
+				device->battery_charging = charging;
+				device->battery_charge = charge;
+				uint8_t message[] = {
+				    (5 << 3) | 2, 0,                          // ProtobufMessage::battery
+				    (1 << 3) | 0, PROTOBUF_INT32(device->id), // Battery::tracker_id
+				    (2 << 3) | 5, PROTOBUF_FLOAT(charge),     // Battery::battery_level
+				    (3 << 3) | 0, charging,                   // Battery::is_charging
+				};
+				message[1] = sizeof(message) - 2;
+				solarxr_ipc_message_write_single(&packet_end, &packet[ARRAY_SIZE(packet)], message,
+				                                 sizeof(message));
+			}
+
+			// report pose
+			struct xrt_space_relation relation = {0};
+			assert(device->xdev->get_tracked_pose != NULL);
+			if (xrt_device_get_tracked_pose(device->xdev, device->input_name, time, &relation) ==
+			        XRT_SUCCESS &&
+			    (relation.relation_flags & XRT_SPACE_RELATION_ORIENTATION_VALID_BIT) != 0) {
+				uint8_t message[30 + 15] = {
+				    (1 << 3) | 2, 0,                          // ProtobufMessage::position
+				    (1 << 3) | 0, PROTOBUF_INT32(device->id), // Position::tracker_id
+				    (5 << 3) | 5, PROTOBUF_FLOAT(relation.pose.orientation.x), // Position::qx
+				    (6 << 3) | 5, PROTOBUF_FLOAT(relation.pose.orientation.y), // Position::qy
+				    (7 << 3) | 5, PROTOBUF_FLOAT(relation.pose.orientation.z), // Position::qz
+				    (8 << 3) | 5, PROTOBUF_FLOAT(relation.pose.orientation.w), // Position::qw
+				    (9 << 3) | 0, 3, // Position::data_source = DataSource::FULL
+				};
+				uint32_t message_len = sizeof(message);
+				if ((relation.relation_flags & XRT_SPACE_RELATION_POSITION_VALID_BIT) != 0) {
+					const uint8_t position[15] = {
+					    (2 << 3) | 5, PROTOBUF_FLOAT(relation.pose.position.x), // Position::x
+					    (3 << 3) | 5, PROTOBUF_FLOAT(relation.pose.position.y), // Position::y
+					    (4 << 3) | 5, PROTOBUF_FLOAT(relation.pose.position.z), // Position::z
+					};
+					memcpy(&message[sizeof(message) - sizeof(position)], position,
+					       sizeof(position));
+				} else {
+					message_len -= 15;
+				}
+				message[1] = message_len - 2;
+				solarxr_ipc_message_write_single(&packet_end, &packet[ARRAY_SIZE(packet)], message,
+				                                 message_len);
+				if ((relation.relation_flags & XRT_SPACE_RELATION_ORIENTATION_TRACKED_BIT) != 0) {
+					status = 1; // Status::OK
+				}
+			}
+		}
+
+		// report tracking status
+		if (status != device->last_status) {
+			device->last_status = status;
+			uint8_t message[] = {
+			    (4 << 3) | 2, 0,                          // ProtobufMessage::tracker_status
+			    (1 << 3) | 0, PROTOBUF_INT32(device->id), // TrackerStatus::tracker_id
+			    (2 << 3) | 0, status,                     // TrackerStatus::status
+			};
+			message[1] = sizeof(message) - 2;
+			solarxr_ipc_message_write_single(&packet_end, &packet[ARRAY_SIZE(packet)], message,
+			                                 sizeof(message));
+		}
+	}
+
+	// flush queued messages to socket
+	if (packet_end != packet) {
+		solarxr_ipc_socket_send_raw(&feeder->socket, packet, packet_end - packet);
+	}
+	os_mutex_unlock(&feeder->mutex);
+}
+
+static bool
+filter_feeder_device(struct xrt_device *const device, const enum u_logging_level log_level)
+{
+	if (device == NULL || !device->supported.orientation_tracking) {
+		return false;
+	}
+	if (device->events.destroy.listeners.prev == NULL) {
+		U_LOG_IFL_E(log_level, "Device \"%s\" [serial=\"%s\"] was not initialized properly; skipping",
+		            device->str, device->serial);
+		return false;
+	}
+	return true;
+}
+
+bool
+feeder_set_devices(struct feeder *const feeder, struct xrt_device *const devices[const], const uint32_t devices_len)
+{
+	uint32_t device_count = 0;
+	for (uint32_t i = 0; i < devices_len; ++i) {
+		device_count += filter_feeder_device(devices[i], feeder->socket.log_level);
+	}
+	os_mutex_lock(&feeder->mutex);
+	for (uint32_t i = 0, devices_len = feeder->devices_len; i < devices_len; ++i) {
+		// The feeder protocol doesn't define a 'removed' message so
+		// the best we can do is the status to `DISCONNECTED`
+		if (feeder->devices[i].last_status != 0) {
+			uint8_t message[] = {
+			    [sizeof(struct solarxr_ipc_message)] = (4 << 3) | 2,
+			    0, // ProtobufMessage::tracker_status
+			    (1 << 3) | 0,
+			    PROTOBUF_INT32(feeder->devices[i].id), // TrackerStatus::tracker_id
+			    (2 << 3) | 0,
+			    0, // TrackerStatus::status = Status::DISCONNECTED
+			};
+			message[sizeof(struct solarxr_ipc_message) + 1] =
+			    sizeof(message) - sizeof(struct solarxr_ipc_message) - 2;
+			solarxr_ipc_socket_send_raw(&feeder->socket, message,
+			                            solarxr_ipc_message_inline(message, sizeof(message)));
+		}
+
+		// unregister destroy listener
+		if (feeder->devices[i].base.link.prev != NULL && feeder->devices[i].base.link.next != NULL) {
+			xrt_list_remove(&feeder->devices[i].base.link);
+		}
+		feeder->devices[i] = (struct feeder_device){0};
+	}
+
+	// ensure IPC connection and device capacity
+	struct feeder_device *new_devices = NULL;
+	if (device_count != 0 &&
+	    (solarxr_ipc_socket_is_connected(&feeder->socket) ||
+	     solarxr_ipc_socket_connect(&feeder->socket,
+	                                solarxr_ipc_socket_find(feeder->socket.log_level, "SlimeVRInput")))) {
+		new_devices = realloc(feeder->devices, device_count * sizeof(*new_devices));
+	}
+
+	bool result;
+	if (new_devices == NULL) {
+		U_LOG_IFL_D(feeder->socket.log_level, "Clearing SolarXR feeder list");
+		free(feeder->devices);
+		feeder->devices = NULL;
+		feeder->devices_len = 0;
+		result = device_count == 0;
+	} else {
+		U_LOG_IFL_D(feeder->socket.log_level, "Setting SolarXR feeder xdevs:");
+		feeder->devices = new_devices;
+		feeder->devices_len = device_count;
+		for (uint32_t i = 0; i < devices_len; ++i) {
+			// must match condition used to compute `device_count`
+			if (!filter_feeder_device(devices[i], U_LOGGING_RAW)) {
+				continue;
+			}
+
+			// find a suitable pose input to report
+			enum xrt_input_name input_name = XRT_INPUT_GENERIC_TRACKER_POSE;
+			for (size_t input = 0, input_count = devices[i]->input_count; input < input_count; ++input) {
+				if (XRT_GET_INPUT_TYPE(devices[i]->inputs[input].name) == XRT_INPUT_TYPE_POSE) {
+					input_name = devices[i]->inputs[input].name;
+					break;
+				}
+			}
+
+			uint8_t role = 0;
+			const char *role_name = "NONE";
+			switch (devices[i]->device_type) {
+			case XRT_DEVICE_TYPE_HMD: {
+				role = 19;
+				role_name = "HMD";
+			} break;
+			case XRT_DEVICE_TYPE_RIGHT_HAND_CONTROLLER: {
+				role = 14;
+				role_name = "RIGHT_CONTROLLER";
+			} break;
+			case XRT_DEVICE_TYPE_LEFT_HAND_CONTROLLER: {
+				role = 13;
+				role_name = "LEFT_CONTROLLER";
+			} break;
+			case XRT_DEVICE_TYPE_ANY_HAND_CONTROLLER: {
+				role = 21;
+				role_name = "GENERIC_CONTROLLER";
+			} break;
+			default:;
+			}
+
+			// initialize state for the device
+			assert(new_devices - feeder->devices < feeder->devices_len);
+			const uint32_t id = feeder->next_id++;
+			*new_devices = (struct feeder_device){
+			    .base.notify = feeder_device_detach,
+			    .xdev = devices[i],
+			    .feeder = feeder,
+			    .input_name = input_name,
+			    .id = id,
+			    .last_status = UINT8_MAX,
+			};
+
+			// listen for destroy so we can safely clean up references to the xdev
+			xrt_signal_register(&devices[i]->events.destroy, &new_devices->base);
+
+			// advance head
+			++new_devices;
+
+			// announce the new tracker
+			const uint32_t serial_len = strlen(devices[i]->serial), name_len = strlen(devices[i]->str);
+			const uint8_t message_1[] = {
+			    (3 << 3) | 2, PROTOBUF_INT32(0),  // ProtobufMessage::tracker_added
+			    (1 << 3) | 0, PROTOBUF_INT32(id), // TrackerAdded::tracker_id
+			    (4 << 3) | 0, role,               // TrackerAdded::tracker_role
+			    (2 << 3) | 2, PROTOBUF_INT32(serial_len),
+			};
+			const uint8_t message_2[] = {
+			    (3 << 3) | 2,
+			    PROTOBUF_INT32(name_len),
+			};
+			uint8_t packet[sizeof(struct solarxr_ipc_message) + sizeof(message_1) +
+			               sizeof(devices[i]->serial) + sizeof(message_2) + sizeof(devices[i]->str)];
+			struct solarxr_ipc_message *const message =
+			    solarxr_ipc_message_start(packet, &packet[ARRAY_SIZE(packet)]);
+			solarxr_ipc_message_write(message, &packet[ARRAY_SIZE(packet)], message_1, sizeof(message_1));
+			solarxr_ipc_message_write(message, &packet[ARRAY_SIZE(packet)],
+			                          (const uint8_t *)devices[i]->serial,
+			                          serial_len); // TrackerAdded::tracker_serial
+			solarxr_ipc_message_write(message, &packet[ARRAY_SIZE(packet)], message_2, sizeof(message_2));
+			solarxr_ipc_message_write(message, &packet[ARRAY_SIZE(packet)],
+			                          (const uint8_t *)devices[i]->str,
+			                          name_len); // TrackerAdded::tracker_name
+			const uint32_t packet_len = solarxr_ipc_message_end(message, &(uint8_t *){packet});
+			if (packet_len == 0) {
+				U_LOG_IFL_E(feeder->socket.log_level, "solarxr_ipc_message_end() failed");
+				assert(false);
+				continue;
+			}
+			const uint8_t tracker_added[] = {
+			    PROTOBUF_INT32(packet_len - sizeof(*message) - sizeof((uint8_t[]){0, PROTOBUF_INT32(0)})),
+			};
+			memcpy(&message->body[1], tracker_added, sizeof(tracker_added));
+			solarxr_ipc_socket_send_raw(&feeder->socket, packet, packet_len);
+			U_LOG_IFL_D(feeder->socket.log_level,
+			            "    \"%s\" [id=%" PRIu32 " serial=\"%s\" role=TrackerRole::%s]", devices[i]->str,
+			            id, devices[i]->serial, role_name);
+		}
+		assert(new_devices - feeder->devices == feeder->devices_len);
+		result = true;
+	}
+	os_mutex_unlock(&feeder->mutex);
+	return result;
+}
+
+bool
+feeder_init(struct feeder *const feeder, const enum u_logging_level log_level)
+{
+	solarxr_ipc_socket_init(&feeder->socket, log_level);
+	return os_mutex_init(&feeder->mutex) == 0;
+}
+
+void
+feeder_fini(struct feeder *const feeder)
+{
+	feeder_set_devices(feeder, NULL, 0);
+	os_mutex_destroy(&feeder->mutex);
+	solarxr_ipc_socket_destroy(&feeder->socket);
+}
diff --git a/src/xrt/drivers/solarxr/feeder.h b/src/xrt/drivers/solarxr/feeder.h
new file mode 100644
index 000000000..51acbdf4a
--- /dev/null
+++ b/src/xrt/drivers/solarxr/feeder.h
@@ -0,0 +1,62 @@
+// Copyright 2025, rcelyte
+// SPDX-License-Identifier: BSL-1.0
+/*!
+ * @file
+ * @brief  SolarXR pose feeder
+ * @ingroup drv_solarxr
+ */
+
+#pragma once
+#include "solarxr_ipc_socket.h"
+
+#include "os/os_threading.h"
+
+/*!
+ * Object that observes a collection of @ref xrt_device objects,
+ * reporting their poses and status to a SolarXR server over IPC
+ * @ingroup drv_solarxr
+ */
+struct feeder_device;
+struct feeder
+{
+	struct os_mutex mutex;
+	struct solarxr_ipc_socket socket;
+	uint32_t next_id;
+	uint32_t devices_len;
+	struct feeder_device *devices;
+};
+
+bool
+feeder_init(struct feeder *feeder, enum u_logging_level log_level);
+
+void
+feeder_fini(struct feeder *feeder);
+
+/*!
+ * Poll all observed xdevs and
+ *
+ * Holds the mutex during most of the operation.
+ *
+ * @param feeder self
+ * @param time Timestamp used to query device poses
+ *
+ * @public @memberof feeder
+ */
+void
+feeder_send_feedback(struct feeder *feeder); // thread safe
+
+/*!
+ * Set the list of devices to observe and announce them to the server
+ *
+ * Holds the mutex during most of the operation.
+ *
+ * @param feeder self
+ * @param devices array of devices
+ * @param devices_len size of @p devices
+ *
+ * @return true on success.
+ *
+ * @public @memberof feeder
+ */
+bool
+feeder_set_devices(struct feeder *feeder, struct xrt_device *const devices[], uint32_t devices_len); // thread safe
diff --git a/src/xrt/drivers/solarxr/protocol.h b/src/xrt/drivers/solarxr/protocol.h
index 35c1dd917..b397dff41 100644
--- a/src/xrt/drivers/solarxr/protocol.h
+++ b/src/xrt/drivers/solarxr/protocol.h
@@ -89,10 +89,12 @@ struct solarxr_tracker_id
 	uint8_t tracker_num;
 };
 
+typedef FLATBUFFERS_VECTOR(char) flatbuffers_vector_char_t;
+
 struct solarxr_tracker_info
 { // table solarxr_protocol.data_feed.tracker.TrackerInfo
 	enum solarxr_body_part body_part;
-	FLATBUFFERS_VECTOR(char) display_name;
+	flatbuffers_vector_char_t display_name;
 };
 
 typedef struct
@@ -120,10 +122,12 @@ typedef struct
 	flatbuffers_uoffset_t offset;
 } solarxr_device_data_t;
 
+typedef FLATBUFFERS_VECTOR(solarxr_tracker_data_t) flatbuffers_vector_solarxr_tracker_data_t;
+
 struct solarxr_device_data
 { // table solarxr_protocol.data_feed.device_data.DeviceData
 	uint8_t id;
-	FLATBUFFERS_VECTOR(solarxr_tracker_data_t) trackers; // solarxr_protocol.data_feed.tracker.TrackerData[]
+	flatbuffers_vector_solarxr_tracker_data_t trackers; // solarxr_protocol.data_feed.tracker.TrackerData[]
 };
 
 typedef struct
@@ -139,12 +143,15 @@ struct solarxr_bone
 	struct xrt_vec3 head_position_g;
 };
 
+typedef FLATBUFFERS_VECTOR(solarxr_device_data_t) flatbuffers_vector_solarxr_device_data_t;
+typedef FLATBUFFERS_VECTOR(solarxr_bone_t) flatbuffers_vector_solarxr_bone_t;
+
 struct solarxr_data_feed_update
-{                                                          // table solarxr_protocol.data_feed.DataFeedUpdate
-	FLATBUFFERS_VECTOR(solarxr_device_data_t) devices; // solarxr_protocol.data_feed.device_data.DeviceData[]
-	FLATBUFFERS_VECTOR(solarxr_tracker_data_t)
-	synthetic_trackers;                       // solarxr_protocol.data_feed.tracker.TrackerData[]
-	FLATBUFFERS_VECTOR(solarxr_bone_t) bones; // solarxr_protocol.data_feed.Bone[]
+{                                                         // table solarxr_protocol.data_feed.DataFeedUpdate
+	flatbuffers_vector_solarxr_device_data_t devices; // solarxr_protocol.data_feed.device_data.DeviceData[]
+	flatbuffers_vector_solarxr_tracker_data_t
+	    synthetic_trackers;                  // solarxr_protocol.data_feed.tracker.TrackerData[]
+	flatbuffers_vector_solarxr_bone_t bones; // solarxr_protocol.data_feed.Bone[]
 };
 
 enum solarxr_data_feed_message_type
@@ -214,11 +221,14 @@ typedef struct
 	flatbuffers_uoffset_t offset;
 } solarxr_message_bundle_t;
 
+typedef FLATBUFFERS_VECTOR(solarxr_data_feed_message_header_t) flatbuffers_vector_solarxr_data_feed_message_header_t;
+typedef FLATBUFFERS_VECTOR(solarxr_rpc_message_header_t) flatbuffers_vector_solarxr_rpc_message_header_t;
+
 struct solarxr_message_bundle
 { // table solarxr_protocol.MessageBundle
-	FLATBUFFERS_VECTOR(solarxr_data_feed_message_header_t)
-	data_feed_msgs;                                            // solarxr_protocol.data_feed.DataFeedMessageHeader[]
-	FLATBUFFERS_VECTOR(solarxr_rpc_message_header_t) rpc_msgs; // solarxr_protocol.rpc.RpcMessageHeader[]
+	flatbuffers_vector_solarxr_data_feed_message_header_t
+	    data_feed_msgs;                                       // solarxr_protocol.data_feed.DataFeedMessageHeader[]
+	flatbuffers_vector_solarxr_rpc_message_header_t rpc_msgs; // solarxr_protocol.rpc.RpcMessageHeader[]
 };
 
 bool
diff --git a/src/xrt/drivers/solarxr/solarxr_device.c b/src/xrt/drivers/solarxr/solarxr_device.c
index 29c0f9716..58fdcb143 100644
--- a/src/xrt/drivers/solarxr/solarxr_device.c
+++ b/src/xrt/drivers/solarxr/solarxr_device.c
@@ -2,6 +2,7 @@
 // SPDX-License-Identifier: BSL-1.0
 
 #include "solarxr_interface.h"
+#include "feeder.h"
 #include "protocol.h"
 #include "solarxr_ipc_message.h"
 #include "solarxr_ipc_socket.h"
@@ -41,6 +42,7 @@ struct solarxr_generic_tracker
 struct solarxr_device
 {
 	struct xrt_device base;
+	struct feeder feeder;
 	struct os_thread thread;
 	struct solarxr_ipc_socket socket;
 	struct os_mutex mutex;
@@ -305,7 +307,7 @@ solarxr_device_handle_trackers(struct solarxr_device *const device,
 	for (uint32_t i = 0; i < trackers_len; ++i) {
 		struct solarxr_tracker_data data;
 		if (!read_solarxr_tracker_data(&data, buffer.data, buffer.length, &trackers[i])) {
-			U_LOG_IFL_W(debug_get_log_option_solarxr_log(), "read_solarxr_device_data() failed");
+			U_LOG_IFL_E(debug_get_log_option_solarxr_log(), "read_solarxr_device_data() failed");
 			continue;
 		}
 
@@ -557,7 +559,7 @@ solarxr_network_thread(void *const ptr)
 		struct solarxr_message_bundle bundle;
 		if (!read_solarxr_message_bundle(&bundle, buffer.data, buffer.length,
 		                                 (const solarxr_message_bundle_t *)buffer.data)) {
-			U_LOG_IFL_W(debug_get_log_option_solarxr_log(), "read_solarxr_message_bundle() failed");
+			U_LOG_IFL_E(debug_get_log_option_solarxr_log(), "read_solarxr_message_bundle() failed");
 			continue;
 		}
 
@@ -568,7 +570,7 @@ solarxr_network_thread(void *const ptr)
 			struct solarxr_rpc_message_header header;
 			if (!read_solarxr_rpc_message_header(&header, buffer.data, buffer.length,
 			                                     &bundle.rpc_msgs.data[i])) {
-				U_LOG_IFL_W(debug_get_log_option_solarxr_log(),
+				U_LOG_IFL_E(debug_get_log_option_solarxr_log(),
 				            "read_solarxr_rpc_message_header() failed");
 				continue;
 			}
@@ -624,6 +626,8 @@ solarxr_network_thread(void *const ptr)
 			continue;
 		}
 
+		feeder_send_feedback(&device->feeder);
+
 		os_mutex_lock(&device->mutex);
 
 		FLATBUFFERS_VECTOR(solarxr_bone_t) bones = {0};
@@ -631,7 +635,7 @@ solarxr_network_thread(void *const ptr)
 			struct solarxr_data_feed_message_header header;
 			if (!read_solarxr_data_feed_message_header(&header, buffer.data, buffer.length,
 			                                           &bundle.data_feed_msgs.data[0])) {
-				U_LOG_IFL_W(debug_get_log_option_solarxr_log(),
+				U_LOG_IFL_E(debug_get_log_option_solarxr_log(),
 				            "read_solarxr_data_feed_message_header() failed");
 				continue;
 			}
@@ -646,7 +650,7 @@ solarxr_network_thread(void *const ptr)
 					if (!read_solarxr_device_data(
 					        &device_data, buffer.data, buffer.length,
 					        &header.message.data_feed_update.devices.data[j])) {
-						U_LOG_IFL_W(debug_get_log_option_solarxr_log(),
+						U_LOG_IFL_E(debug_get_log_option_solarxr_log(),
 						            "read_solarxr_device_data() failed");
 						continue;
 					}
@@ -672,7 +676,7 @@ solarxr_network_thread(void *const ptr)
 			for (size_t i = 0; i < bones.length; ++i) {
 				struct solarxr_bone bone;
 				if (!read_solarxr_bone(&bone, buffer.data, buffer.length, &bones.data[i])) {
-					U_LOG_IFL_W(debug_get_log_option_solarxr_log(), "read_solarxr_bone() failed");
+					U_LOG_IFL_E(debug_get_log_option_solarxr_log(), "read_solarxr_bone() failed");
 					continue;
 				}
 
@@ -760,6 +764,8 @@ solarxr_device_destroy(struct xrt_device *xdev)
 		os_thread_destroy(&device->thread);
 	}
 
+	feeder_fini(&device->feeder);
+
 	for (size_t i = 0; i < ARRAY_SIZE(device->trackers); ++i) {
 		m_relation_history_destroy(&device->trackers[i]);
 	}
@@ -826,11 +832,12 @@ solarxr_device_create_xdevs(struct xrt_tracking_origin *const tracking_origin,
 		return 0;
 	}
 
-	if (out_xdevs_cap > 1 + MAX_GENERIC_TRACKERS) {
-		out_xdevs_cap = 1 + MAX_GENERIC_TRACKERS;
+	struct solarxr_device *device;
+	if (out_xdevs_cap > 1 + ARRAY_SIZE(device->trackers)) {
+		out_xdevs_cap = 1 + ARRAY_SIZE(device->trackers);
 	}
 
-	struct solarxr_device *const device = U_DEVICE_ALLOCATE(struct solarxr_device, U_DEVICE_ALLOC_NO_FLAGS, 2, 0);
+	device = U_DEVICE_ALLOCATE(struct solarxr_device, U_DEVICE_ALLOC_NO_FLAGS, 2, 0);
 	device->base.name = XRT_DEVICE_FB_BODY_TRACKING;
 	device->base.device_type = XRT_DEVICE_TYPE_BODY_TRACKER;
 	strncpy(device->base.str, "SolarXR IPC Connection", sizeof(device->base.str) - 1);
@@ -861,10 +868,11 @@ solarxr_device_create_xdevs(struct xrt_tracking_origin *const tracking_origin,
 	memset(device->tracker_ids, 0xff, sizeof(device->tracker_ids));
 
 	uint32_t trackers_len = 0;
-	struct solarxr_generic_tracker *trackers[MAX_GENERIC_TRACKERS];
+	struct solarxr_generic_tracker *trackers[ARRAY_SIZE(device->trackers)];
 
 	// `solarxr_device_destroy()` asserts unless both have attempted initialization
-	if (os_mutex_init(&device->mutex) != 0) {
+	if (((int)!feeder_init(&device->feeder, debug_get_log_option_solarxr_log()) | os_mutex_init(&device->mutex)) !=
+	    0) {
 		goto fail;
 	}
 
@@ -1150,54 +1158,71 @@ solarxr_device_create_xdevs(struct xrt_tracking_origin *const tracking_origin,
 			goto fail;
 		}
 
-		uint32_t tracker_descs_len = 0;
-		const solarxr_tracker_data_t *tracker_descs[ARRAY_SIZE(device->trackers)];
+		uint32_t tracker_datas_len = 0;
+		struct solarxr_tracker_data tracker_datas[ARRAY_SIZE(device->trackers)];
 		if (debug_get_bool_option_solarxr_raw_trackers()) {
-			for (uint32_t i = 0; i < header.message.data_feed_update.devices.length; ++i) {
+			const flatbuffers_vector_solarxr_device_data_t devices =
+			    header.message.data_feed_update.devices;
+			for (const solarxr_device_data_t *device = devices.data, *const devices_end =
+			                                                             &device[devices.length];
+			     device < devices_end; ++device) {
 				struct solarxr_device_data device_data;
-				if (!read_solarxr_device_data(&device_data, buffer.data, buffer.length,
-				                              &header.message.data_feed_update.devices.data[i])) {
-					U_LOG_IFL_W(debug_get_log_option_solarxr_log(),
+				if (!read_solarxr_device_data(&device_data, buffer.data, buffer.length, device)) {
+					U_LOG_IFL_E(debug_get_log_option_solarxr_log(),
 					            "read_solarxr_device_data() failed");
 					continue;
 				}
-
-				uint32_t length = device_data.trackers.length;
-				if (length >= ARRAY_SIZE(tracker_descs) - tracker_descs_len) {
-					length = ARRAY_SIZE(tracker_descs) - tracker_descs_len;
-					header.message.data_feed_update.devices.length = i; // early exit
-				}
-
-				for (uint32_t j = 0; j < length; ++j) {
-					tracker_descs[tracker_descs_len++] = &device_data.trackers.data[j];
+				for (const solarxr_tracker_data_t *tracker = device_data.trackers.data,
+				                                  *const end = &tracker[device_data.trackers.length];
+				     tracker < end; ++tracker) {
+					if (tracker_datas_len >= ARRAY_SIZE(tracker_datas)) {
+						device = devices_end - 1; // break outer
+						break;
+					}
+					if (!read_solarxr_tracker_data(&tracker_datas[tracker_datas_len], buffer.data,
+					                               buffer.length, tracker)) {
+						U_LOG_IFL_E(debug_get_log_option_solarxr_log(),
+						            "read_solarxr_tracker_data() failed");
+						continue;
+					}
+					++tracker_datas_len;
 				}
 			}
 		} else {
-			tracker_descs_len =
-			    MIN(header.message.data_feed_update.synthetic_trackers.length, ARRAY_SIZE(tracker_descs));
-			for (uint32_t i = 0; i < tracker_descs_len; ++i) {
-				tracker_descs[i] = &header.message.data_feed_update.synthetic_trackers.data[i];
+			const flatbuffers_vector_solarxr_tracker_data_t synthetic_trackers =
+			    header.message.data_feed_update.synthetic_trackers;
+			for (const solarxr_tracker_data_t *tracker = synthetic_trackers.data,
+			                                  *const end = &tracker[synthetic_trackers.length];
+			     tracker < end; ++tracker) {
+				if (tracker_datas_len >= ARRAY_SIZE(tracker_datas)) {
+					break;
+				}
+				if (!read_solarxr_tracker_data(&tracker_datas[tracker_datas_len], buffer.data,
+				                               buffer.length, tracker)) {
+					U_LOG_IFL_E(debug_get_log_option_solarxr_log(),
+					            "read_solarxr_tracker_data() failed");
+					continue;
+				}
+				if (tracker_datas[tracker_datas_len].tracker_id.has_device_id) {
+					continue; // filter out loopback feeder devices
+				}
+				++tracker_datas_len;
 			}
 		}
 
 		U_LOG_IFL_I(debug_get_log_option_solarxr_log(), "Enumerated %" PRIu32 " SolarXR %s trackers",
-		            tracker_descs_len, debug_get_bool_option_solarxr_raw_trackers() ? "physical" : "synthetic");
+		            tracker_datas_len, debug_get_bool_option_solarxr_raw_trackers() ? "physical" : "synthetic");
 
-		if (tracker_descs_len > out_xdevs_cap - 1) {
-			U_LOG_IFL_W(debug_get_log_option_solarxr_log(),
+		if (tracker_datas_len > out_xdevs_cap - 1) {
+			U_LOG_IFL_E(debug_get_log_option_solarxr_log(),
 			            "Not enough xdev slots! Omitting %" PRIu32 " trackers",
-			            tracker_descs_len - (out_xdevs_cap - 1));
-			tracker_descs_len = out_xdevs_cap - 1;
+			            tracker_datas_len - (out_xdevs_cap - 1));
+			tracker_datas_len = out_xdevs_cap - 1;
 		}
 
-		for (uint32_t i = 0; i < tracker_descs_len; ++i) {
-			struct solarxr_tracker_data data;
-			if (!read_solarxr_tracker_data(&data, buffer.data, buffer.length, tracker_descs[i])) {
-				U_LOG_IFL_W(debug_get_log_option_solarxr_log(), "read_solarxr_device_data() failed");
-				continue;
-			}
-
-			const wchar_t id = solarxr_tracker_id_to_wchar(data.tracker_id);
+		for (const struct solarxr_tracker_data *data = tracker_datas, *const end = &data[tracker_datas_len];
+		     data < end; ++data) {
+			const wchar_t id = solarxr_tracker_id_to_wchar(data->tracker_id);
 
 			struct solarxr_generic_tracker *const tracker =
 			    U_DEVICE_ALLOCATE(struct solarxr_generic_tracker, U_DEVICE_ALLOC_NO_FLAGS, 1, 0);
@@ -1219,27 +1244,27 @@ solarxr_device_create_xdevs(struct xrt_tracking_origin *const tracking_origin,
 			tracker->base.inputs[0].name = XRT_INPUT_GENERIC_TRACKER_POSE;
 			tracker->role = SOLARXR_BODY_PART_NONE;
 
-			device->tracker_ids[i] = id;
-			m_relation_history_create(&device->trackers[i]);
+			assert(trackers_len < ARRAY_SIZE(trackers));
+			device->tracker_ids[trackers_len] = id;
+			m_relation_history_create(&device->trackers[trackers_len]);
 			tracker->parent = device;
-			tracker->index = i;
-			tracker->history = device->trackers[i];
-			device->tracker_refs[i] = tracker;
+			tracker->index = trackers_len;
+			tracker->history = device->trackers[trackers_len];
+			device->tracker_refs[trackers_len] = tracker;
 
-			assert(trackers_len < ARRAY_SIZE(trackers));
 			trackers[trackers_len++] = tracker;
 
-			if (!data.has_info) {
+			if (!data->has_info) {
 				continue;
 			}
 
-			if (data.info.body_part < ARRAY_SIZE(device->bones)) {
-				tracker->role = data.info.body_part;
+			if (data->info.body_part < ARRAY_SIZE(device->bones)) {
+				tracker->role = data->info.body_part;
 			}
 
-			if (data.info.display_name.length != 0) {
+			if (data->info.display_name.length != 0) {
 				snprintf(tracker->base.str, sizeof(tracker->base.str), "SolarXR Tracker \"%.*s\"",
-				         (unsigned)data.info.display_name.length, data.info.display_name.data);
+				         (unsigned)data->info.display_name.length, data->info.display_name.data);
 			}
 		}
 	}
@@ -1264,3 +1289,27 @@ fail:
 	solarxr_device_destroy(&device->base);
 	return 0;
 }
+
+bool
+solarxr_device_set_feeder_devices(struct xrt_device *const device,
+                                  struct xrt_device *const xdevs[const],
+                                  const uint32_t xdev_count)
+{
+	struct solarxr_device *const solarxr = solarxr_device(device);
+	if (solarxr == NULL) {
+		return false;
+	}
+	uint32_t filtered_xdevs_len = 0;
+	struct xrt_device *filtered_xdevs[XRT_SYSTEM_MAX_DEVICES];
+	for (uint32_t i = 0; i < xdev_count; ++i) {
+		if (xdevs[i] == device || solarxr_generic_tracker(xdevs[i]) != NULL) {
+			continue;
+		}
+		if (filtered_xdevs_len >= ARRAY_SIZE(filtered_xdevs)) {
+			U_LOG_IFL_E(debug_get_log_option_solarxr_log(), "too many feeder devices");
+			return false;
+		}
+		filtered_xdevs[filtered_xdevs_len++] = xdevs[i];
+	}
+	return feeder_set_devices(&solarxr->feeder, filtered_xdevs, filtered_xdevs_len);
+}
diff --git a/src/xrt/drivers/solarxr/solarxr_interface.h b/src/xrt/drivers/solarxr/solarxr_interface.h
index c56bb15b1..15916484f 100644
--- a/src/xrt/drivers/solarxr/solarxr_interface.h
+++ b/src/xrt/drivers/solarxr/solarxr_interface.h
@@ -31,6 +31,9 @@ solarxr_device_create(struct xrt_tracking_origin *const tracking_origin)
 	return out;
 }
 
+bool
+solarxr_device_set_feeder_devices(struct xrt_device *solarxr, struct xrt_device *const xdevs[], uint32_t xdev_count);
+
 
 #ifdef __cplusplus
 }
-- 
2.52.0

